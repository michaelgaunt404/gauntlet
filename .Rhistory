tmp = tmp %>%
mutate(zscore_flag = case_when(
abs(zscore) < threshold ~ str_glue("Under {threshold}sd threshold"),
T~str_glue("Over {threshold}sd threshold")) %>%
as.factor(),
zscore_flag_num = case_when(
abs(zscore) < threshold ~ 0,
T~1)
)
}
return(tmp)
}
data.frame(value = test) %>%
ts_zscore(width = 9)
data.frame(value = test) %>%
ts_zscore(width = 10)
data.frame(value = test) %>%
ts_zscore(width = 11)
(test-mean(test))/sd(test)
scale(test)
numeric_vector = c(rnorm(10, 10, 3), 100)
roll_mad(numeric_vector)
scale(numeric_vector)
scale(numeric_vector)[11,]
#'
#' @examples
#'
#'numeric_vector = c(rnorm(10, 10, 3), 100)
#'
#'roll_mad(numeric_vector)
#'
#'#compare to zscore
#'scale(numeric_vector)[11,]
# TODO should be able to pick tail, head, or centered for window alignment
roll_mad = function(values){
((abs(values-median(values, na.rm = T)))/
median(abs(values-median(values, na.rm = T)), na.rm = T))
}
numeric_vector = c(rnorm(10, 10, 3), 100)
roll_mad(numeric_vector)
#'
#' @examples
#'
#'numeric_vector = c(rnorm(10, 10, 3), 100)
#'
#'roll_mad(numeric_vector)
#'
#'#compare to zscore
#'scale(numeric_vector)[11,]
# TODO should be able to pick tail, head, or centered for window alignment
roll_mad = function(values, last = F){
((abs(values-median(values, na.rm = T)))/
median(abs(values-median(values, na.rm = T)), na.rm = T)) %>%
{ if (!last) (.) %>%
tail(1)
else .}
}
numeric_vector = c(rnorm(10, 10, 3), 100)
roll_mad(numeric_vector)
library(tidyverse)
#'
#' @examples
#'
#'numeric_vector = c(rnorm(10, 10, 3), 100)
#'
#'roll_mad(numeric_vector)
#'
#'#compare to zscore
#'scale(numeric_vector)[11,]
# TODO should be able to pick tail, head, or centered for window alignment
roll_mad = function(values, last = F){
((abs(values-median(values, na.rm = T)))/
median(abs(values-median(values, na.rm = T)), na.rm = T)) %>%
{ if (!last) (.) %>%
tail(1)
else .}
}
numeric_vector = c(rnorm(10, 10, 3), 100)
roll_mad(numeric_vector)
((abs(values-median(values, na.rm = T)))/
median(abs(values-median(values, na.rm = T)), na.rm = T)) %>%
{ if (last) (.) %>%
tail(1)
else .}
#'
#' @examples
#'
#'numeric_vector = c(rnorm(10, 10, 3), 100)
#'
#'roll_mad(numeric_vector)
#'
#'#compare to zscore
#'scale(numeric_vector)[11,]
# TODO should be able to pick tail, head, or centered for window alignment
roll_mad = function(values, last = F){
((abs(values-median(values, na.rm = T)))/
median(abs(values-median(values, na.rm = T)), na.rm = T)) %>%
{ if (last) (.) %>%
tail(1)
else .}
}
numeric_vector = c(rnorm(10, 10, 3), 100)
roll_mad(numeric_vector)
roll_mad(numeric_vector)
roll_mad(numeric_vector, last = T)
scale(numeric_vector)[,1]
test_data = data.frame(value = c(rnorm(10, 10, 3), 100))
test_data = data.frame(value = c(rnorm(50, 10, 3), 100))
test_data = data.frame(value = c(rnorm(50, 10, 3), rnorm(3, 100, 3)))
mad_anomoly_df = function(data, window = 20){
data = data %>%
mutate(index_forced = row_number())
temp_list = list()
for (i in 1:(nrow(data)-window)){
print(i)
#make window subset
temp_df = data[i:(i+window),]
#make distance matrix for window
window_values = temp_df %>%
pull(value)
temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values, last = T))
mad_df = dgt2(abs(window_values-median(window_values, na.rm = T))/
median(abs(window_values-median(window_values, na.rm = T)), na.rm = T)) %>%
data.frame(mad_values = .) %>%
cbind(index_forced = temp_df$index_forced)
temp_list[[i]] = temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values))
}
#collapses summary list objects
temp_dffff =
temp_list %>%
data.table::rbindlist(fill=TRUE)
return(temp_dffff)
}
test_data %>%
mad_anomoly_df()
#helper to make pop up window to alert user
alert_me = function(){
windows(bg = 'red', width = 100, height = 75);
data.frame(x = 0, y = 0, text = "ALERT: SCRIPT HAS COMPLETED") %>%
ggplot(aes(x, y, label = text)) + geom_label(size = 10) +
labs(x = "", y = "") +
theme(axis.text.x=element_blank(),
axis.ticks.x=element_blank(),
axis.text.y=element_blank(),
axis.ticks.y=element_blank(),
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
plot.background = element_rect(fill = "red"),
panel.background = element_rect(fill = "red")
)
}
#helper to make floor divides
#generally used to make bins
floor_divide = function(value, floor){
(value %/% floor)*floor
}
#plusEqual operator
`%+=%` = function(e1,e2) eval.parent(substitute(e1 <- e1 + e2))
#evaluate string functions
#eg works if var is "input$something > num" in shiny
strg_fun_eval = function(text){
eval(rlang::parse_expr(text))
}
#takes quick counts for columns and their items
quick_value_count = function(df, rows, column, filter = NA){
if(is.na(filter)){
df[rows,] %>%
select(all_of(column)) %>%
nrow()
} else {
df[rows,] %>%
select(all_of(column)) %>%
filter(!!as.symbol(column) == filter) %>%
nrow()
}
}
#cleans df using common operations
quick_clean = function(df, na_marker){
df %>%
na_if(na_marker) %>%
janitor::clean_names() %>%
janitor::remove_empty(c("cols", "rows"))
}
pretty_char = function(col){
col %>%
stringr::str_replace_all(., "_", " ") %>%
stringr::str_to_title(.)
}
dgt0 = function(x){
round(x, 0)
}
dgt1 = function(x){
round(x, 1)
}
dgt2 = function(x){
round(x, 2)
}
dgt3 = function(x){
round(x, 3)
}
#corrects column to start with zero
crrct0 = function(x){
x-x[1]
}
#function: changes negative to zero
lmt0 = function(x){
ifelse(x<0, 0, x)
}
#function: formats numbers to pretty strings
pretty_num = function(vector, rnd = 0){
digit = vector %>%
dgt0()
case_when(str_length(abs(digit))>9~paste0(round((digit/1e6), rnd), "B")
,str_length(abs(digit))>6~paste0(round((digit/1e6), rnd), "M")
,str_length(abs(digit))>3~paste0(round((digit/1e3), rnd), "k")
,str_length(abs(digit))>0~paste(digit)
,T~"Undefined")
}
#shiny specific=================================================================
list = list(closable = F,
collapsed = F,
collapsible = T,
width = "100%",
solidHeader = T,
status = "primary")
quick_bs = function(id, title, text, trigger = "hover"){
tagList(
bsButton(inputId = id, label = "Info", icon = icon("question"), style = "info", size = "small"),
bsPopover(id = id, title = title,
content = text,
placement = "right",
trigger = trigger)
)
}
#takes master shiny input list and extracts list elements by name match
#string can take "|" operator
get_list_items = function(input_list, suffix = NA, string, purrr = T){
if (purrr){
input_list[names(input_list)[(str_detect(names(input_list) , paste0("_", suffix))+str_detect(names(input_list), string))==2]]
} else {
input_list[names(input_list)[str_detect(names(input_list), string)]]
}
}
#makes common box that works for most purposes
#objects need to be in a list
# boxPlus_common = function(title = NA, object_in_box = NA, collapsed = F){
#   boxPlus(title = title,
#           closable = F,
#           collapsed = collapsed,
#           collapsible = T,
#           width = "100%",
#           solidHeader = T,
#           status = "primary",
#           object_in_box)
# }
#makes common box that works for most purposes
#objects need to be in a list
box_common = function(title = NA, object_in_box = NA, collapsed = F){
box(title = title,
# closable = F,
collapsed = collapsed,
collapsible = T,
width = "100%",
solidHeader = T,
status = "primary",
object_in_box)
}
#creates an empty row of a given height
#for shiny usage
spacer_row = function(size){
fluidRow(box(height = size))
}
#creates function for modals
modal = function(trigger, msg){
observeEvent(trigger, {
showModal(modalDialog(
msg,
size = "l",
easyClose = TRUE
))
})
}
#automates aggregating counts and percents for different groupings of data
count_percent_zscore = function(data, grp_c = ..., grp_p = ..., grp_z = ...,
col = count, prefix = NULL,
rnd = NULL, cntr_scl = FALSE){
#summarizing column has to be 'count'
tmp = data %>%
group_by(across({{grp_c}})) %>%
summarise(count = sum({{col}})) %>%
ungroup() %>%
group_by(across({{grp_p}})) %>%
mutate(percent = ({{col}}/sum({{col}})) %>%
{ if (!is.null(rnd)) round(., rnd) else .}
) %>%
ungroup() %>%
{ if (cntr_scl) (.) %>%
group_by(across({{grp_z}})) %>%
mutate(zscore = as.vector(scale({{col}})))
else .}
if (is.null(prefix)){
tmp
} else {
newname1 = str_glue("{prefix}_count")
newname2 = str_glue("{prefix}_percent")
rename(tmp, !!newname1 := count, !!newname2 := percent)
}
}
mad_anomoly_df = function(data, window = 20){
data = data %>%
mutate(index_forced = row_number())
temp_list = list()
for (i in 1:(nrow(data)-window)){
print(i)
#make window subset
temp_df = data[i:(i+window),]
#make distance matrix for window
window_values = temp_df %>%
pull(value)
temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values, last = T))
mad_df = dgt2(abs(window_values-median(window_values, na.rm = T))/
median(abs(window_values-median(window_values, na.rm = T)), na.rm = T)) %>%
data.frame(mad_values = .) %>%
cbind(index_forced = temp_df$index_forced)
temp_list[[i]] = temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values))
}
#collapses summary list objects
temp_dffff =
temp_list %>%
data.table::rbindlist(fill=TRUE)
return(temp_dffff)
}
test_data %>%
mad_anomoly_df()
data = test_data
data
data = data %>%
mutate(index_forced = row_number())
temp_list = list()
window = 20
i = 1
print(i)
#make window subset
temp_df = data[i:(i+window),]
#make distance matrix for window
window_values = temp_df %>%
pull(value)
temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values, last = T))
mad_df = dgt2(abs(window_values-median(window_values, na.rm = T))/
median(abs(window_values-median(window_values, na.rm = T)), na.rm = T)) %>%
data.frame(mad_values = .) %>%
cbind(index_forced = temp_df$index_forced)
temp_list[[i]] = temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values))
mad_df
temp_df
temp_df %>%
tail(1)
temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values, last = T))
window_values
temp_df
temp_df %>%
tail(1)
temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values, last = T))
mad_anomoly_df = function(data, window = 20){
data = data %>%
mutate(index_forced = row_number())
temp_list = list()
for (i in 1:(nrow(data)-window)){
print(i)
#make window subset
temp_df = data[i:(i+window),]
#make distance matrix for window
window_values = temp_df %>%
pull(value)
# temp_df %>%
#   tail(1) %>%
#   mutate(mad_value = roll_mad(window_values, last = T))
#
# # mad_df = dgt2(abs(window_values-median(window_values, na.rm = T))/
# #                 median(abs(window_values-median(window_values, na.rm = T)), na.rm = T)) %>%
# #   data.frame(mad_values = .) %>%
# #   cbind(index_forced = temp_df$index_forced)
temp_list[[i]] = temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values, last = T))
}
#collapses summary list objects
temp_dffff =
temp_list %>%
data.table::rbindlist(fill=TRUE)
return(temp_dffff)
}
test_data %>%
mad_anomoly_df()
test_data = data.frame(index = 1:33,
value = c(rnorm(50, 10, 3), rnorm(3, 100, 3)))
test_data
test_data = data.frame(index = 1:33,
value = c(rnorm(50, 10, 3), rnorm(3, 100, 3)))
test_data
test_data = data.frame(index = 1:33)
test_data
test_data = data.frame(index = 1:33,
value = c(rnorm(50, 10, 3), rnorm(3, 100, 3)))
test_data
c(rnorm(50, 10, 3), rnorm(3, 100, 3))
test_data = data.frame(index = 1:53,
value = c(rnorm(50, 10, 3), rnorm(3, 100, 3)))
test_data
test_data = data.frame(index = 1:53,
value = c(rnorm(25, 10, 3), rnorm(3, 100, 3), rnorm(25, 10, 3)))
test_data
test_data %>%
mad_anomoly_df()
mad_anomoly_df = function(data, window = 20){
data = data %>%
mutate(index_forced = row_number())
temp_list = list()
for (i in 1:(nrow(data)-window)){
print(i)
#make window subset
temp_df = data[i:(i+window),]
#make distance matrix for window
window_values = temp_df %>%
pull(value)
# temp_df %>%
#   tail(1) %>%
#   mutate(mad_value = roll_mad(window_values, last = T))
#
# # mad_df = dgt2(abs(window_values-median(window_values, na.rm = T))/
# #                 median(abs(window_values-median(window_values, na.rm = T)), na.rm = T)) %>%
# #   data.frame(mad_values = .) %>%
# #   cbind(index_forced = temp_df$index_forced)
temp_list[[i]] = temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values, last = T))
}
#collapses summary list objects
temp_dffff =
temp_list %>%
data.table::rbindlist(fill=TRUE) %>%
select(!index_forced)
return(temp_dffff)
}
test_data %>%
mad_anomoly_df()
test_data %>%
mad_anomoly_df(window = 7)
ts_mad = function(data, window = 20){
data = data %>%
mutate(index_forced = row_number())
temp_list = list()
for (i in 1:(nrow(data)-window)){
print(i)
#make window subset
temp_df = data[i:(i+window),]
#make distance matrix for window
window_values = temp_df %>%
pull(value)
temp_list[[i]] = temp_df %>%
tail(1) %>%
mutate(mad_value = roll_mad(window_values, last = T))
}
#collapses summary list objects
temp_dffff =
temp_list %>%
data.table::rbindlist(fill=TRUE) %>%
select(!index_forced)
return(temp_dffff)
}
test_data %>%
ts_mad(window = 7)
devtools::document()
devtools::install()
library(gauntlet)
test_data = data.frame(index = 1:53,
value = c(rnorm(25, 10, 3)
,rnorm(3, 100, 3)
,rnorm(25, 10, 3)))
test_data %>%
ts_mad(window = 7)
library(tidyverse)
test_data %>%
ts_mad(window = 7)
devtools::document()
devtools::install()
library(gauntlet)
ts_mad()
library(tidyverse)
test_data = data.frame(index = 1:53,
value = c(rnorm(25, 10, 3)
,rnorm(3, 100, 3)
,rnorm(25, 10, 3)))
test_data %>%
ts_mad(window = 7)
